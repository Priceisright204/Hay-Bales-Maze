<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title>Hay Bales Maze</title>
<script type="text/javascript">
//globals
var INTERVAL = 20;  //line spacing

//size of canvas based on number of grids
var X_GRIDS = 25;
var Y_GRIDS = 9;

var CANVAS_WIDTH = INTERVAL * X_GRIDS
var CANVAS_HEIGHT = INTERVAL * Y_GRIDS

var MOVEDIST=2; //distance line moves on each refresh

var obstacles = []; //contains a list of all obstacles.
                    //Each obstacle contains dictionaries:
                        // { "type":  <obstacle type>
                        //   "orient": <obstacle orientation>
                        //   "x":     <x-coordinate of origin>
                        //   "y":     <y-coordinate of origin> }

function setPage()
{
    var canvas = document.getElementById("canvas");
    canvas.height = CANVAS_HEIGHT;
    canvas.width = CANVAS_WIDTH;
}

function drawGrid() 
{
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");

    //refresh the page
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.strokeStyle="#DDDDDD"; //gray color
    context.beginPath();

    //vertical grid marks
    for (var x=0; x<=canvas.width; x+=INTERVAL) {
        context.moveTo(x, 0); 
        context.lineTo(x, canvas.height);
    }

    //horizontal grid marks
    for (var y=0; y<canvas.height; y+=INTERVAL) {
        context.moveTo(0, y); 
        context.lineTo(canvas.width, y);
    }
        
    context.stroke(); 

    drawObstacles(canvas, context);
}

function drawObstacles(canvas, context)
{

    context.beginPath();
    context.strokeStyle="#FF0000";

    for(var i=0; i<obstacles.length; i++)
    {
        var x1 = obstacles[i]["x"] * INTERVAL;
        var y1 = obstacles[i]["y"] * INTERVAL;
        var moveX;
        var moveY;
        
        if(obstacles[i]["orient"]=="vertical")
            {
                moveX = 0;
                moveY = INTERVAL;
            }
        else if(obstacles[i]["orient"]=="horizontal")
            {
                moveX = INTERVAL;
                moveY = 0;
            }
        context.moveTo(x1, y1);  //Now move the line to the coordinate
        context.lineTo(x1 + moveX, y1 + moveY);  //and draw the hash.
    
    }

    context.stroke(); 

    
}



function clickHandler(event) {
//    alert("Clicked!")
    
    canvas = document.getElementById("canvas");
    var spot = getCursorPosition(canvas, event);
    var x = spot[0];
    var y = spot[1];

    var lessThanX = 0;
    var lessThanY = 0;
    //gets whether it's closer to a horizontal or vertical line
    if (x % INTERVAL < INTERVAL - (x % INTERVAL) )
    { var x_dist = x % INTERVAL }
    else { var x_dist = INTERVAL - (x % INTERVAL)
           lessThanX = 1;
    }

    if (y % INTERVAL < INTERVAL - (y % INTERVAL))
    { var y_dist = y % INTERVAL }
    else { var y_dist = INTERVAL - (y % INTERVAL)
           lessThanY = 1;
    }

    //Now draw a red dash on the closest segment to the click.

    //sets up the context...
    var context = canvas.getContext("2d");
    context.strokeStyle="#FF0000";
    context.beginPath();
    var x1 = x;
    var y1 = y;

    
    if (x_dist < y_dist) {  //closer to vertical line, VERTICAL hash
        var moveX = 0;       //vertical hash mark, so x doesn't move
        var moveY = INTERVAL;
        
        if (lessThanX == 1){
        //user clicked BEHIND grid mark
            while(x1 % INTERVAL != 0) //line up exactly to grid mark
                { x1++; } //it's ++ because you're BEHIND the grid mark
            while(y1 % INTERVAL != 0)
               { y1--; }
        } else {   
            //user clicked IN FRONT of grid mark
            while(x1 % INTERVAL != 0)
                { x1--; }
            while(y1 % INTERVAL != 0)
               { y1--; }
        }

        //now save x and y based on intervals
        var x_int = x1 / INTERVAL;
        var y_int = y1 / INTERVAL;

        //add item to objects list
        var DictItem = {}
        DictItem["type"]="wall"
        DictItem["orient"]="vertical"
        DictItem["x"]=x_int
        DictItem["y"]=y_int
            
        obstacles.push(DictItem) 
    }
    else {      //closer to horizontal line, HORIZONTAL hash
        var moveX = INTERVAL;
        var moveY = 0;  //HORIZONTAL hash, so y doesn't move

        if(lessThanY == 1) {  
        //user clicked BEHIND grid mark
            while(x1 % INTERVAL != 0) //line up exactly to grid mark
                { x1--; } 
            while(y1 % INTERVAL != 0)           
                { y1++; } //it's ++ because you're BEHIND the grid mark
        } else { 
        //user clicked IN FRONT of grid mark
            while(x1 % INTERVAL != 0)
                { x1--; }
            while(y1 % INTERVAL != 0)
                { y1--; }
        }

        //now save x and y based on intervals
        var x_int = x1 / INTERVAL;
        var y_int = y1 / INTERVAL;
        
        //add item to objects list
        var DictItem = {}
        DictItem["type"]="wall"
        DictItem["orient"]="horizontal"
        DictItem["x"]=x_int
        DictItem["y"]=y_int
        obstacles.push(DictItem) 
        
   } 

    context.moveTo(x1, y1);  //Now move the line to the coordinate
    context.lineTo(x1 + moveX, y1 + moveY);  //and draw the hash.

    context.stroke(); 
}


function startMaze()
{

    canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
 
    //spot is in reference to the GRID LINES
    //the actual line is drawn halfway in the middle.
    //it makes obstacle comparisons easier.
    //I subtract half an interval so it doesn't start off the edge.
    var spot = [ 0, canvas.height/INTERVAL - 1/2 , "up" ];
    var pixelsSpot;
    
    //an array containing the distance to the next stop
    //and the information about the next obstacle.
    var stop = checkObstacles(spot);

    //move the line on an interval
    var interval = setInterval(function() {
        context.beginPath();
        context.strokeStyle="#00FF00"; //green

        context.moveTo( Math.round(spot[0]*INTERVAL + INTERVAL/2), 
                         Math.round(spot[1]*INTERVAL + INTERVAL/2) ); 

        switch(spot[2])  //move the line in the right direction,
        {                //while keeping it in reference to the grids.
            case "up":
                pixelsSpot = spot[1]*INTERVAL;
                pixelsSpot -= MOVEDIST;
                spot[1] = pixelsSpot / INTERVAL;
                break;
            case "down":
                pixelsSpot = spot[1]*INTERVAL;
                pixelsSpot += MOVEDIST;
                spot[1] = pixelsSpot / INTERVAL;
                break;
            case "right":
                pixelsSpot = spot[0]*INTERVAL;
                pixelsSpot += MOVEDIST;
                spot[0] = pixelsSpot / INTERVAL;
                break;
            case "left":
                pixelsSpot = spot[0]*INTERVAL;
                pixelsSpot -= MOVEDIST;
                spot[0] = pixelsSpot / INTERVAL;
                break;
        }

        //Check for the next obstacle
        pixelsSpot = stop["dist"]*INTERVAL;
        pixelsSpot -= MOVEDIST;
        stop["dist"] = pixelsSpot / INTERVAL;
        
        if (stop["dist"] <= 0)
        {
            clearInterval(interval);
            alert("You hit an obstacle or went off the edge!");
//            obstacleHandler()
        }
        
        
        //draw the line, ALWAYS keeping it in reference to the grids.
        context.lineTo( Math.round(spot[0]*INTERVAL + INTERVAL/2), 
                        Math.round(spot[1]*INTERVAL + INTERVAL/2) );  
        context.stroke();

/*        if (spot[1]<= -.5)             //to be erased
            { clearInterval(interval);
              alert("You went off the edge!"); }
*/        
    }, 30);  //how often in ms the line is moved.
}

function checkObstacles(spot)
{
    var stop = {};
    var inColumn = [];
    var inRow = [];

    switch(spot[2])
    {
        case "up":
            //check for obstacles in the same COLUMN
            //that are ABOVE your spot.
            //and are oriented HORIZONTALLY
            for (var i=0; i<obstacles.length; i++)
            {
                if(obstacles[i]["x"] == spot[0] &&
                   obstacles[i]["y"] <= spot[1] &&
                   obstacles[i]["orient"] == "horizontal" )
                {
                    inColumn.push(obstacles[i]);                
                }
            }
            //if NONE, then add the TOP edge of the screen.
            if(inColumn.length == 0)
            {
                var DictItem = {}
                DictItem["type"]="edge"
                DictItem["orient"]="horizontal"
                DictItem["x"]=spot[0]
                DictItem["y"]=0
                inColumn.push(DictItem) 
            }
            break;


        case "down":
            //check for obstacles in the same COLUMN
            //that are BELOW your spot
            //and are oriented HORIZONTALLY
            for (var i=0; i<obstacles.length; i++)
            {
                if(obstacles[i]["x"] == spot[0] &&
                   obstacles[i]["y"] >= spot[1] &&
                   obstacles[i]["orient"] == "horizontal" )
                {
                    inColumn.push(obstacles[i]);
                }
            }
            //if NONE, then add the BOTTOM edge of the screen.
            if(inColumn.length == 0)
            {
                var DictItem = {}
                DictItem["type"]="edge"
                DictItem["orient"]="horizontal"
                DictItem["x"]=spot[0]
                DictItem["y"]=document.getElementById("canvas").height /INTERVAL
                inColumn.push(DictItem)
            }
            break;

            
        case "right":
            //check for obstacles in the same ROW
            //that are TO THE RIGHT OF your spot
            //and are oriented VERTICALLY
            for (var i=0; i<obstacles.length; i++)
            {
                if(obstacles[i]["y"] == spot[1] &&
                   obstacles[i]["x"] >= spot[0] &&
                   obstacles[i]["orient"] == "vertical" )
                {
                    inRow.push(obstacles[i]);
                }
            }
            //if NONE, then add the RIGHT edge of the screen.
            if(inColumn.length == 0)
            {
                var DictItem = {}
                DictItem["type"]="edge"
                DictItem["orient"]="vertical"
                DictItem["x"]=document.getElementById("canvas").width /INTERVAL
                DictItem["y"]=spot[1]
                inColumn.push(DictItem)
            }
            break;
        
        
        case "left":    
            //check for obstacles in the same ROW
            //that are TO THE LEFT OF your spot
            //and are oriented VERTICALLY
            for (var i=0; i<obstacles.length; i++)
            {
                if(obstacles[i]["y"] == spot[1] &&
                   obstacles[i]["x"] <= spot[0] &&
                   obstacles[i]["orient"] == "vertical" )
                {
                    inRow.push(obstacles[i]);
                }
            }
            //if NONE, then add the LEFT edge of the screen.
            if(inColumn.length == 0)
            {
                var DictItem = {}
                DictItem["type"]="edge"
                DictItem["orient"]="vertical"
                DictItem["x"]=0
                DictItem["y"]=spot[1]
                inColumn.push(DictItem) 
            }
            break;
    }

    if(inColumn.length > 0) //if up or down
    {   //sort obstacles based on which is CLOSEST to your spot.
        inColumn.sort(function(a, b) {
            var x = Math.abs(a["y"] - spot[1]); 
            var y = Math.abs(b["y"] - spot[1]);
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        } )

        //now return the closest obstacle and it's distance.
        stop["obstacle"] = inColumn[0]
        stop["dist"] = Math.abs(stop["obstacle"]["y"] - spot[1])
    }

    
    if(inRow.length > 0) //if right or left
    {   //sort obstacles based on which is CLOSEST to your spot.
        inRow.sort(function(a, b) {
            var x = Math.abs(a["x"] - spot[0]); 
            var y = Math.abs(b["x"] - spot[0]);
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        } )

        //now return the closest obstacle and it's distance.
        stop["obstacle"] = inRow[0]
        stop["dist"] = Math.abs(stop["obstacle"]["x"] - spot[0])
    }

    return stop;
}

function obstacleHandler()
{
}

function getCursorPosition(canvas, event) {
    //coordinates of the four borders of the canvas
    var rect = canvas.getBoundingClientRect();

    //clientX = the click relative to the page edge
    //rect.left = the canvas edge relative to page
    var x = Math.round(event.clientX - rect.left);
    var y = Math.round(event.clientY - rect.top);

    //the coordinate relative to the canvas
    return [x,y]
}

function zoomIn()
{
    if(INTERVAL <= 35)  //limit to how much you can zoom in.
    {
        INTERVAL += 5;
        CANVAS_WIDTH = INTERVAL * X_GRIDS;
        CANVAS_HEIGHT = INTERVAL * Y_GRIDS;
        setPage();
    }
    drawGrid();
}

function zoomOut()
{
    if(INTERVAL >= 15)  //limit to how much you can zoom out.
    {
        INTERVAL -= 5;
        CANVAS_WIDTH = INTERVAL * X_GRIDS;
        CANVAS_HEIGHT = INTERVAL * Y_GRIDS;
        setPage();
    }
    drawGrid();

}

</script>
</head>
<body onload="setPage(); drawGrid();">
    <input type="submit" value="Start the Maze" onclick="startMaze()"/>
    <input type="submit" value="Zoom In" onclick="zoomIn()"/>
    <input type="submit" value="Zoom Out" onclick="zoomOut()"/>
    </br></br>
    <canvas id="canvas" onclick="clickHandler(event);"></canvas>
</body>
</html>