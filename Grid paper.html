<!DOCTYPE html>
<html>
<head>
<meta charset=utf-8 />
<title id="title">Hay Bales Maze       </title>
<script type="text/javascript">

//GLOBALS
var INTERVAL = 20;  //line spacing

//size of canvas based on number of grids
var X_GRIDS = 25;
var Y_GRIDS = 9;

var CANVAS_WIDTH = INTERVAL * X_GRIDS;
var CANVAS_HEIGHT = INTERVAL * Y_GRIDS;

var MOVEDIST=2; //distance line moves on each refresh

var obstacles = []; //contains a list of all obstacles.
                    //Each obstacle contains dictionaries:
                        // { "type":  <obstacle type>
                        //   "orient": <obstacle orientation>
                        //   "x":     <x-coordinate of origin>
                        //   "y":     <y-coordinate of origin> }

                        
//The location element is declared here as a global variable.
var spot = []; 


//a few housekeeping items that need to happen
//right when the page is loaded.
function setPage()
{
    //the canvas needs to be set to the right size
    //before the spot is initialized, or it will misbehave.
    //So this once, these values get initialized twice.
    var canvas = document.getElementById("canvas");
    canvas.height = CANVAS_HEIGHT;
    canvas.width = CANVAS_WIDTH;

    //The starting location is intialized here.
    //This can't be done when it is defined as a global.

    //The spot is in reference to the GRID LINES
    //the actual line is drawn halfway in the middle of the square.
    //This makes obstacle comparisons easier.
    //Notice, I subtract half an interval 
    //so it doesn't start off the edge.
    spot = [ 0, canvas.height/INTERVAL - 1/2 , "up" ];

    animate_string('title');
    drawGrid();
}

function animate_string(id)   //animates the title
{
    var element = document.getElementById(id);
    var textNode = element.childNodes[0]; // assuming no other children
    var text = textNode.data;

    setInterval(function () 
    {
        text = text.substring(1, text.length) + text[0];
        textNode.data = text;
    }, 175);
}


function drawGrid() 
{
    //make sure the canvas is set to the right size.
    var canvas = document.getElementById("canvas");
    canvas.height = CANVAS_HEIGHT;
    canvas.width = CANVAS_WIDTH;
    
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");

    //refresh the page
    context.clearRect(0, 0, canvas.width, canvas.height);

    context.strokeStyle="#DDDDDD"; //gray color
    context.beginPath();

    //vertical grid marks
    for (var x=0; x<=canvas.width; x+=INTERVAL) {
        context.moveTo(x, 0); 
        context.lineTo(x, canvas.height);
    }

    //horizontal grid marks
    for (var y=0; y<canvas.height; y+=INTERVAL) {
        context.moveTo(0, y); 
        context.lineTo(canvas.width, y);
    }
        
    context.stroke(); 

    drawObstacles(canvas, context);
}

function drawObstacles(canvas, context)
{

    context.beginPath();
    context.strokeStyle="#FF0000";

    for(var i=0; i<obstacles.length; i++)
    {
        var x1 = obstacles[i]["x"] * INTERVAL;
        var y1 = obstacles[i]["y"] * INTERVAL;
        var moveX;
        var moveY;
        
        if(obstacles[i]["orient"]=="vertical")
            {
                moveX = 0;
                moveY = INTERVAL;
            }
        else if(obstacles[i]["orient"]=="horizontal")
            {
                moveX = INTERVAL;
                moveY = 0;
            }
        context.moveTo(x1, y1);  //Now move the line to the coordinate
        context.lineTo(x1 + moveX, y1 + moveY);  //and draw the hash.
    
    }

    context.stroke(); 

    
}



function clickHandler(event) {
//    alert("Clicked!")
    
    canvas = document.getElementById("canvas");
    var location = getCursorPosition(canvas, event);
    var x = location[0];
    var y = location[1];

    var lessThanX = 0;
    var lessThanY = 0;
    //gets whether it's closer to a horizontal or vertical line
    if (x % INTERVAL < INTERVAL - (x % INTERVAL) )
    { var x_dist = x % INTERVAL }
    else { var x_dist = INTERVAL - (x % INTERVAL)
           lessThanX = 1;
    }

    if (y % INTERVAL < INTERVAL - (y % INTERVAL))
    { var y_dist = y % INTERVAL }
    else { var y_dist = INTERVAL - (y % INTERVAL)
           lessThanY = 1;
    }

    //Now draw a red dash on the closest segment to the click.

    //sets up the context...
    var context = canvas.getContext("2d");
    context.strokeStyle="#FF0000";
    context.beginPath();
    var x1 = x;
    var y1 = y;

    
    if (x_dist < y_dist) {  //closer to vertical line, VERTICAL hash
        var moveX = 0;       //vertical hash mark, so x doesn't move
        var moveY = INTERVAL;
        
        if (lessThanX == 1){
        //user clicked BEHIND grid mark
            while(x1 % INTERVAL != 0) //line up exactly to grid mark
                { x1++; } //it's ++ because you're BEHIND the grid mark
            while(y1 % INTERVAL != 0)
               { y1--; }
        } else {   
            //user clicked IN FRONT of grid mark
            while(x1 % INTERVAL != 0)
                { x1--; }
            while(y1 % INTERVAL != 0)
               { y1--; }
        }

        //now save x and y based on intervals
        var x_int = x1 / INTERVAL;
        var y_int = y1 / INTERVAL;

        //add item to objects list
        var DictItem = {}
        DictItem["type"]="wall"
        DictItem["orient"]="vertical"
        DictItem["x"]=x_int
        DictItem["y"]=y_int
            
        obstacles.push(DictItem) 
    }
    else {      //closer to horizontal line, HORIZONTAL hash
        var moveX = INTERVAL;
        var moveY = 0;  //HORIZONTAL hash, so y doesn't move

        if(lessThanY == 1) {  
        //user clicked BEHIND grid mark
            while(x1 % INTERVAL != 0) //line up exactly to grid mark
                { x1--; } 
            while(y1 % INTERVAL != 0)           
                { y1++; } //it's ++ because you're BEHIND the grid mark
        } else { 
        //user clicked IN FRONT of grid mark
            while(x1 % INTERVAL != 0)
                { x1--; }
            while(y1 % INTERVAL != 0)
                { y1--; }
        }

        //now save x and y based on intervals
        var x_int = x1 / INTERVAL;
        var y_int = y1 / INTERVAL;
        
        //add item to objects list
        var DictItem = {}
        DictItem["type"]="wall"
        DictItem["orient"]="horizontal"
        DictItem["x"]=x_int
        DictItem["y"]=y_int
        obstacles.push(DictItem) 
        
   } 

    context.moveTo(x1, y1);  //Now move the line to the coordinate
    context.lineTo(x1 + moveX, y1 + moveY);  //and draw the hash.

    context.stroke(); 
}


function startMaze()
{
    canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
 
    var pixelsSpot;
        
    //an array containing the distance to the next stop
    //and the information about the next obstacle.
    var stop = checkObstacles();

    //move the line on an interval
    var time_interval = setInterval(function() {
        context.beginPath();
        context.strokeStyle="#00FF00"; //green

        context.moveTo( Math.round(spot[0]*INTERVAL + INTERVAL/2), 
                         Math.round(spot[1]*INTERVAL + INTERVAL/2) ); 

        switch(spot[2])  //move the line in the right direction,
        {                //while keeping it in reference to the grids.
            case "up":
                pixelsSpot = spot[1]*INTERVAL;
                pixelsSpot -= MOVEDIST;
                spot[1] = pixelsSpot / INTERVAL;
                break;
            case "down":
                pixelsSpot = spot[1]*INTERVAL;
                pixelsSpot += MOVEDIST;
                spot[1] = pixelsSpot / INTERVAL;
                break;
            case "right":
                pixelsSpot = spot[0]*INTERVAL;
                pixelsSpot += MOVEDIST;
                spot[0] = pixelsSpot / INTERVAL;
                break;
            case "left":
                pixelsSpot = spot[0]*INTERVAL;
                pixelsSpot -= MOVEDIST;
                spot[0] = pixelsSpot / INTERVAL;
                break;
        }

        
        //draw the line, ALWAYS keeping it in reference to the grids.
        context.lineTo( Math.round(spot[0]*INTERVAL + INTERVAL/2), 
                        Math.round(spot[1]*INTERVAL + INTERVAL/2) );  
        context.stroke();

        //Check for the next obstacle
        pixelsSpot = stop["dist"]*INTERVAL;
        pixelsSpot -= MOVEDIST;
        stop["dist"] = pixelsSpot / INTERVAL;

        //If you hit an obstacle, clear the interval
        //and handle each obstacle differently.
        if (stop["dist"] <= 0)
        {
            clearInterval(time_interval);
            obstacleHandler(stop["obstacle"]);
        }        
        
    }, 30);  //how often in ms the line is moved.
}

//===================================================


function obstacleHandler(stop_obstacle)
{
    //just in case the interval is an odd number,
    //and you didn't land exactly on INTERVAL
    //this will fix that problem. :-)
    spot[0]=Math.round(spot[0])
    spot[1]=Math.round(spot[1])


    var sides = [];  //will be populated with which sides
                     //of the square have obstacles in them

    for (var i=0; i<obstacles.length; i++)
    {
        if(  obstacles[i]["x"] == spot[0] &&
             obstacles[i]["y"] == spot[1] &&
             obstacles[i]["orient"] == "vertical" &&
             obstacles[i]["type"] != "permeable" )
            {  sides.push("left");  }
        
        if(  obstacles[i]["x"] == spot[0] &&
             obstacles[i]["y"] == spot[1] &&
             obstacles[i]["orient"] == "horizontal" &&
             obstacles[i]["type"] != "permeable" )
            {  sides.push("top");  }
        
        if(  obstacles[i]["x"] == (spot[0] + 1) &&
             obstacles[i]["y"] == spot[1] &&
             obstacles[i]["orient"] == "vertical" &&
             obstacles[i]["type"] != "permeable" )
            {  sides.push("right");  }
                        
        if ( obstacles[i]["x"] == spot[0] &&
             obstacles[i]["y"] == (spot[1] + 1) &&
             obstacles[i]["orient"] == "horizontal" &&
             obstacles[i]["type"] != "permeable" )
            {  sides.push("bottom");  }
    }

    var directions = [] //will be populated with the direction 
                        // choices the user has.

    //now handle the directions based on where you are oriented.
    switch(spot[2])  
    {   //switch case for your direction when you stopped.
        case "up":  //we KNOW there is an obstacle on TOP.
            if( stop_obstacle["type"] == "permeable" )
            { directions.push("forward") }
            
            if( sides.includes("left") &&
                sides.includes("right") )
            { directions.push("backward") }

            if( sides.includes("left") &&
                !sides.includes("right") )
            { directions.push("right") }
            
            if( !sides.includes("left") &&
                sides.includes("right") )
            { directions.push("left") }
            
            if( !sides.includes("right") &&
                !sides.includes("left") )
            { directions.push("right")
              directions.push("left") }
            break

        case "down":  //we KNOW there is an obstacle BELOW.
            if( stop_obstacle["type"] == "permeable" )
            { directions.push("forward") }
            
            if( sides.includes("left") &&
                sides.includes("right") )
            { directions.push("backward") }

            if( sides.includes("left") &&
                !sides.includes("right") )
            { directions.push("left") } //left and right are swapped
                                        //when moving down
            if( !sides.includes("left") &&
                sides.includes("right") )
            { directions.push("right") } //left and right are swapped
                                        //when moving down
            if( !sides.includes("right") &&
                !sides.includes("left") )
            { directions.push("right")
              directions.push("left") }
            break;

        case "right": //we KNOW there is an obstacle TO THE RIGHT.
            if( stop_obstacle["type"] == "permeable" )
            { directions.push("forward") }
            
            if( sides.includes("top") &&
                sides.includes("bottom") )
            { directions.push("backward") }

            if( sides.includes("top") &&
                !sides.includes("bottom") )
            { directions.push("right") }

            if( !sides.includes("top") &&
                sides.includes("bottom") )
            { directions.push("left") }

            if( !sides.includes("top") &&
                !sides.includes("bottom") )
            { directions.push("right")
              directions.push("left") }
            break;

        case "left": //we KNOW there is an obstacle TO THE LEFT.
            if( stop_obstacle["type"] == "permeable" )
            { directions.push("forward") }
            
            if( sides.includes("top") &&
                sides.includes("bottom") )
            { directions.push("backward") }

            if( sides.includes("top") &&
                !sides.includes("bottom") )
            { directions.push("left") }

            if( !sides.includes("top") &&
                sides.includes("bottom") )
            { directions.push("right") }

            if( !sides.includes("top") &&
                !sides.includes("bottom") )
            { directions.push("right")
              directions.push("left") }
            break;
    }

    //This will get erased eventually.
    spot = [ 0, canvas.height/INTERVAL - 1/2 , "up" ];

    
    if(stop_obstacle["type"] == "edge")
    {
        spot = [ 0, canvas.height/INTERVAL - 1/2 , "up" ];
        directions = [];
        alert("You went off the edge!")
    }

    alert("Possible directions: " + directions);

    
    if(directions.length == 1 && directions[0] != "backward")
    {
        if(directions[0] == "right")
        { turnRight(); }
    
        if(directions[0] == "left")
        { turnLeft(); }        
    }

    if(directions.length == 1 && directions[0] == "backward")
    {
        turnBackwards();
    }
}

//======================================================
//======================================================

function turnRight()
{
    alert("I'm turning right!")
}

function turnLeft()
{
    alert("I'm turning left!")
}

function turnBackwards()
{
    alert("Reversing direction!")
}

function checkObstacles()
{
    var stop = {};
    var inColumn = [];
    var inRow = [];

    switch(spot[2])
    {
        case "up":
            //check for obstacles in the same COLUMN
            //that are ABOVE your spot.
            //and are oriented HORIZONTALLY
            for (var i=0; i<obstacles.length; i++)
            {
                if(obstacles[i]["x"] == spot[0] &&
                   obstacles[i]["y"] <= spot[1] &&
                   obstacles[i]["orient"] == "horizontal" )
                {
                    inColumn.push(obstacles[i]);                
                }
            }
            //if NONE, then add the TOP edge of the screen.
            if(inColumn.length == 0)
            {
                var DictItem = {}
                DictItem["type"]="edge"
                DictItem["orient"]="horizontal"
                DictItem["x"]=spot[0]
                DictItem["y"]=0 - 0.5
                inColumn.push(DictItem) 
            }
            break;

        case "down":
            //check for obstacles in the same COLUMN
            //that are BELOW your spot
            //and are oriented HORIZONTALLY
            for (var i=0; i<obstacles.length; i++)
            {
                if(obstacles[i]["x"] == spot[0] &&
                   obstacles[i]["y"] >= spot[1] &&
                   obstacles[i]["orient"] == "horizontal" )
                {
                    inColumn.push(obstacles[i]);
                }
            }
            //if NONE, then add the BOTTOM edge of the screen.
            if(inColumn.length == 0)
            {
                var DictItem = {}
                DictItem["type"]="edge"
                DictItem["orient"]="horizontal"
                DictItem["x"]=spot[0]
                DictItem["y"]=document.getElementById("canvas").height/INTERVAL - 0.5
                inColumn.push(DictItem)
            }
            break;
            
        case "right":
            //check for obstacles in the same ROW
            //that are TO THE RIGHT OF your spot
            //and are oriented VERTICALLY
            for (var i=0; i<obstacles.length; i++)
            {
                if(obstacles[i]["y"] == spot[1] &&
                   obstacles[i]["x"] >= spot[0] &&
                   obstacles[i]["orient"] == "vertical" )
                {
                    inRow.push(obstacles[i]);
                }
            }
            //if NONE, then add the RIGHT edge of the screen.
            if(inColumn.length == 0)
            {
                var DictItem = {}
                DictItem["type"]="edge"
                DictItem["orient"]="vertical"
                DictItem["x"]=document.getElementById("canvas").width/INTERVAL - 0.5
                DictItem["y"]=spot[1]
                inColumn.push(DictItem)
            }
            break;
        
        case "left":    
            //check for obstacles in the same ROW
            //that are TO THE LEFT OF your spot
            //and are oriented VERTICALLY
            for (var i=0; i<obstacles.length; i++)
            {
                if(obstacles[i]["y"] == spot[1] &&
                   obstacles[i]["x"] <= spot[0] &&
                   obstacles[i]["orient"] == "vertical" )
                {
                    inRow.push(obstacles[i]);
                }
            }
            //if NONE, then add the LEFT edge of the screen.
            if(inColumn.length == 0)
            {
                var DictItem = {}
                DictItem["type"]="edge"
                DictItem["orient"]="vertical"
                DictItem["x"]=0 - 0.5
                DictItem["y"]=spot[1]
                inColumn.push(DictItem) 
            }
            break;
    }

    if(inColumn.length > 0) //if up or down
    {   //sort obstacles based on which is CLOSEST to your spot.
        inColumn.sort(function(a, b) {
            var x = Math.abs(a["y"] - spot[1]); 
            var y = Math.abs(b["y"] - spot[1]);
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        } )

        //now return the closest obstacle and it's distance.
        stop["obstacle"] = inColumn[0]
        stop["dist"] = Math.abs(stop["obstacle"]["y"] - spot[1])
    }
    
    if(inRow.length > 0) //if right or left
    {   //sort obstacles based on which is CLOSEST to your spot.
        inRow.sort(function(a, b) {
            var x = Math.abs(a["x"] - spot[0]); 
            var y = Math.abs(b["x"] - spot[0]);
            return ((x < y) ? -1 : ((x > y) ? 1 : 0));
        } )

        //now return the closest obstacle and it's distance.
        stop["obstacle"] = inRow[0]
        stop["dist"] = Math.abs(stop["obstacle"]["x"] - spot[0])
    }

    return stop;
}


function getCursorPosition(canvas, event) {
    //coordinates of the four borders of the canvas
    var rect = canvas.getBoundingClientRect();

    //clientX = the click relative to the page edge
    //rect.left = the canvas edge relative to page
    var x = Math.round(event.clientX - rect.left);
    var y = Math.round(event.clientY - rect.top);

    //the coordinate relative to the canvas
    return [x,y]
}

function zoomIn()
{
    if(INTERVAL <= 35)  //limit to how much you can zoom in.
    {
        INTERVAL += 5;
        CANVAS_WIDTH = INTERVAL * X_GRIDS;
        CANVAS_HEIGHT = INTERVAL * Y_GRIDS;
        drawGrid();
    }
}

function zoomOut()
{
    if(INTERVAL >= 15)  //limit to how much you can zoom out.
    {
        INTERVAL -= 5;
        CANVAS_WIDTH = INTERVAL * X_GRIDS;
        CANVAS_HEIGHT = INTERVAL * Y_GRIDS;
        drawGrid();
    }
}



</script>
</head>
<body onload="setPage();">
    <input type="submit" value="Start the Maze" onclick="startMaze()"/>
    <input type="submit" value="Zoom In" onclick="zoomIn()"/>
    <input type="submit" value="Zoom Out" onclick="zoomOut()"/>
    <input type="submit" value="Refresh" onclick="drawGrid()" />
    <br/>
    <div id="action" style="border:solid brown; display:inline-block; padding:5px; margin-top:5px;">Action Square</div>
    <br/>
    <canvas id="canvas" onclick="clickHandler(event);"></canvas>
</body>
</html>